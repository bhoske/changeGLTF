// Copyright (c) 2013, Fabrice Robinet
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var Montage = require("montage").Montage;
var Node = require("runtime/node").Node;
var RuntimeTFLoader = require("runtime/runtime-tf-loader").RuntimeTFLoader;
var URL = require("url");
var SceneResourceLoader = require("runtime/scene-resource-loader").SceneResourceLoader;
var Q = require("q");
var Target = require("montage/core/target").Target;
var CSSOM = require("cssom");
var GLTFScene = require("runtime/glTF-scene").glTFScene;
var Material = require("runtime/glTF-material").glTFMaterial;
exports.Scene = Target.specialize( {

    constructor: {
        value: function Scene() {
            this.super();
        }
    },

    _resourcesLoaded: { value: false, writable: true },

    _glTFElement: { value: null, writable: true },

    shouldBeHitTested: { value: false, writable: true },

    glTFElement: {
        get: function() {
            return this._glTFElement;
        },
        set: function(value) {
            this._glTFElement = value;
        }
    },

    _rootNode: { value: null, writable: true },

    rootNode: {
        get: function() {
            if (this.status === "loaded") {
                if (this._rootNode == null) {
                    this._rootNode = Montage.create(Node);
                    this._rootNode.scene = this;
                    this._rootNode.id = this.glTFElement.rootNode.id;
                }
            }
            return this._rootNode;
        }
    },

    sceneResourcesDidPrepare: {
        value: function() {
            if (!this._resourcesLoaded) {
                if (this._prepareToRenderDefer) {
                    this._prepareToRenderDefer.resolve();
                }
                this._resourcesLoaded = true;
                //FIXME: we should pass { scene:scene webGLContext:webGLContext
                //only problem now is pass the webGLContext through the promise properly
                this.dispatchEventNamed("resourcesDidLoad", true, false, this);
                this.status = "loaded";
            }
        }
    },

    isLoaded: {
        value: function() {
            return this.status == "loaded";
        }
    },

    status: { value: 0, writable: true},

    styleSheetsLoaded: { value: false, writable: true},

    styleSheets: { value: null, writable: true},

    loadCSSStyles: {
        value: function() {
            if (document.styleSheets == null)
                return;
            var packages = Object.keys(require.packages);
            var styleSheetsLoaded = 0;
            var styleSheetsCount = document.styleSheets.length;
            var i;
            var styleSheet;
            var styleSheets = [];
            this.styleSheets = {};
            
            for (i = 0; i < styleSheetsCount; i++) {    
                styleSheet = document.styleSheets[i]; 
                if (styleSheet.href != null) {
                    if (styleSheet.href.indexOf(packages[0]) != -1) {
                        //HACK: packages[0] is guaranted to be the entry point
                         //we just want the CSS from this project but not the ones from its dependencies
                        if (styleSheet.href.indexOf(packages[0] + "node_modules") == -1) {
                            styleSheets.push(styleSheet);
                        }
                    }
                }  
            }

            styleSheetsCount = styleSheets.length;
            if (styleSheetsCount === 0) {
                this.styleSheetsLoaded = true;
                return;
            }

            styleSheets.forEach(function(styleSheet) {
                    var self = this;
                    //FIXME: handle error
                    var cssPath = styleSheet.href;
                    var cssXHR = new XMLHttpRequest();
                    cssXHR.open("GET", cssPath, true);
                    cssXHR.onreadystatechange = function() {
                        if (cssXHR.readyState == 4) {
                            if (cssXHR.status == 200 || cssXHR.status == 0) {
                                var cssDescription = CSSOM.parse(cssXHR.responseText);
                                self.styleSheets[styleSheet.href] = cssDescription;
                                styleSheetsLoaded++;  
                                if (styleSheetsLoaded === styleSheetsCount) {
                                    self.dispatchEventNamed("styleSheetsDidLoad", true, false, self);
                                }                              
                            }
                        }
                    }
                    cssXHR.send(null);
            }, this);

            return false;                                          
        }
    },

	loadMultipleScenes: {
		value: function() {            
			var paths = [];	

			
		    paths.push("model/ford/Ford_F150_Test_Texture.json");
			
			
			

			var pathsIndex = 0;
			
			var mainScene = Object.create(GLTFScene).init();
			var readerDelegate = {};
			readerDelegate.loadCompleted = function (scene) {
				
				mainScene.baseURL = scene.baseURL;
				mainScene.id = scene.id + pathsIndex;
				mainScene.baseId = scene.baseId + pathsIndex;
				mainScene.ids = scene.ids;
				mainScene._animationManager = scene._animationManager;
				
				mainScene.rootNode.children.push(scene.rootNode);
				pathsIndex++;
				if (paths.length === pathsIndex) {
					this.needsDraw = true;
					this.glTFElement = mainScene;
					this.status = "loaded";
					
					//following lines are addes to handle config file
					mainScene.rootNode.isMaterialSet = false;
					mainScene.rootNode.configFile = mainScene.baseURL+"i3d.config";
					var rootNode= mainScene.rootNode;
					var request = new XMLHttpRequest();
					var result;
					request.onreadystatechange = function() {
						if ((request.readyState == 4) ) {
						result  = request.responseText;	
					   }
					};
					request.open("POST", rootNode.configFile, false);
					request.send(null);
					if(result)
					{
						if(result.search("ColorNodes") != -1)
						{
							var idx = result.indexOf("ColorNodes");
							var sliced_str = result.substr(idx); 
							var idx1 = result.indexOf("\n");
							sliced_str = sliced_str.substr(idx1+1); 
							if(result.search("BodyColor") != -1)
							{
								var idx2 = result.indexOf("BodyColor");
								sliced_str = sliced_str.substr(0,idx2); 
							}
							if(sliced_str.length >0)
							{
								function removeSpaces(str_) //can use trim function instead of this
								{
									var i;
									for(i =0;i<str_.length;i++)
									{
										if(str_[i]=== " " || str_[i] ==="\t" || str_[i] ==="\n")
										{
										}
										else
										{
											break;
										}
									}
									var new_str = str_.substr(i);
									for(i =new_str.length-1;i>= 0;i--)
									{
										if(new_str[i]=== " " || new_str[i] ==="\t" || new_str[i] ==="\n")
										{
										}
										else
										{
											break;
										}
									}
									new_str = new_str.substr(0,i+1);
									return new_str;
								};
								function replaceSpaces(str_)
								{
									var new_str = "";
									for(var i =0;i<str_.length;i++)
									{
										if(str_[i]==" ")
										{
											new_str = new_str.concat("_");
										}
										else
										{
											new_str = new_str.concat(str_[i]);
										}
									}
									return new_str;
								};
								function searchNode(node_,name_) {
								  var return_value = null;
								  var goForChildren = false;
								  if(node_.name)
								  {
									var name1_ = (node_.name).toLowerCase();
									if(name1_ == name_)
									{
										return_value = node_;
									}
									else
										goForChildren = true;
								  }
								  else
									goForChildren = true;
								 if(goForChildren)
								  {
									 for(var i =0 ;i<node_.children.length;i++)
									 {
										return_value = searchNode(node_.children[i],name_);
										if(return_value != null)
											break;
									 }
								  }
								  return return_value;
								};
								function searchMaterialNode(node_) {
								  var return_value = null;
								  if(node_.children.length ==0)
								  {
									return_value = node_;
								  }
								  else
								  {
									 for(var i =0 ;i<node_.children.length;i++)
									 {
										return_value = searchMaterialNode(node_.children[i]);
										if(return_value != null)
											break;
									 }
								  }
								  return return_value;
								};
    							function setMaterialForAllNode(node_,tempMaterial) {
								  if(node_.children.length ==0)
								  {
									var meshes = node_._properties.meshes; 
									if(meshes)
									{
										for(var i = 0;i<meshes.length;i++)
										{
											var primitives = meshes[i].primitives;
											if(primitives)
											{
												for(var j =0 ;j<primitives.length;j++)
												{
													primitives[j]._material = tempMaterial;
												}
											}
										}
									}
								  }
								  else
								  {
									 for(var i =0 ;i<node_.children.length;i++)
									 {
										setMaterialForAllNode(node_.children[i],tempMaterial);
									}
								  }
								};
								var split_lines = sliced_str.split("\n");
								for(var j = 0;j<split_lines.length;j=j+4)
								{
									var part_name = split_lines[j];
									//console.log("part_name : "+part_name);
									if(part_name.search("BodyColor") != -1)
									{
										j = split_lines.length;
										break;
									}
									var part_name_no_spaces  = removeSpaces(part_name);
									var part_name_lowercase  = part_name_no_spaces.toLowerCase();
									part_name_lowercase = part_name_lowercase.substr(0,part_name_lowercase.length-2); 
									part_name_lowercase = replaceSpaces(part_name_lowercase);
									//console.log("part_name_lowercase : "+part_name_lowercase);
									var mynode_ = searchNode(rootNode,part_name_lowercase);
									
									if( mynode_ !== null)
									{
										var mynode1_ = searchMaterialNode(mynode_);
										if(mynode1_)
										{
											if(mynode1_._properties.meshes[0].primitives[0]._material)
											{
												
												var old_mat = mynode1_._properties.meshes[0].primitives[0]._material;
												//creating material and applying for all node
												/*var diffuse = mat._parameters.diffuse !== undefined ? mat._parameters.diffuse : [0.8,0.8,0.0] ;
												var ambient = mat._parameters.ambient !== undefined ? mat._parameters.ambient : [0.0,0.0,0.0] ;
												var emission = mat._parameters.emission !== undefined ? mat._parameters.emission : [0.0,0.0,0.0] ;
												var specular = mat._parameters.specular !== undefined ? mat._parameters.specular : [0.0,0.0,0.0] ;
												var shininess = mat._parameters.shininess !== undefined ? mat._parameters.shininess : 100.0 ;
												var reflectivity = mat._parameters.reflectivity !== undefined ? mat._parameters.reflectivity : 0.0 ;
												var transparency = mat._parameters.transparency !== undefined ? mat._parameters.transparency : 1.0 ;
												*/
												var param = old_mat.parameters;
												/*var new_prop = {};
												for (var key in prop) {
												  if (prop.hasOwnProperty(key)) {
													//alert(prop[key]);
													new_prop.key = prop[key];
												  }
												}*/
												var new_param = Object.clone(param);
												console.log("node_name : "+ part_name_lowercase);
												for(var k =1;k<4;k++)
												{
													var next_line = split_lines[j+k];
													var split_ = next_line.split("=");
													var property_ =  split_[0];
													var property_lowercase  = property_.toLowerCase();
													property_lowercase  = removeSpaces(property_lowercase);
													//property_lowercase = property_lowercase.substr(0,property_lowercase.length-1); 
													var property_value =  split_[1];
													var property_value_lowercase  = property_value.toLowerCase();
													property_value_lowercase  = removeSpaces(property_value_lowercase);
													property_value_lowercase = property_value_lowercase.substr(0,property_value_lowercase.length-1); 
													if(property_lowercase == "diffuse" || property_lowercase == "reflectivity" || property_lowercase == "transparency")
													{
														console.log("property : "+ property_lowercase + " property_value : "+property_value_lowercase);
														if(property_value_lowercase.length>0)
														{
															if(property_lowercase == "diffuse")
															{
																var diffuse_new = property_value_lowercase.split(" ");
																
																new_param.diffuse.value[0] = diffuse_new[0];
																new_param.diffuse.value[1] = diffuse_new[1];
																new_param.diffuse.value[2] = diffuse_new[2];
																
															}
															if(property_lowercase == "reflectivity")
															{
																if(new_param.reflectivity)
																	new_param.reflectivity.value = property_value_lowercase;
															}
														}
													}
												}
												var tempMaterial = Object.create(Material).init("mymaterial"+j);
												tempMaterial.parameters =  new_param;
												tempMaterial.technique = old_mat.technique;
												
												setMaterialForAllNode(mynode_,tempMaterial);
											}
											
										}
									}
								}
							}
						}
					}
				}
			}.bind(this);
			paths.forEach( function(path) {
				var loader = Object.create(RuntimeTFLoader);
				loader.initWithPath(path);
				loader.delegate = readerDelegate;
				loader.load(null /* userInfo */, null /* options */);
			}, this);
		}
	},    
    path: {
        set: function(value) {
            //Work-around until montage implements textfield that do not send continous input..
            if (value) {
                if (value.indexOf(".json") === -1)
                    return;

                var URLObject = URL.parse(value);
                if (!URLObject.scheme) {
                    var packages = Object.keys(require.packages);
                    //HACK: for demo, packages[0] is guaranted to be the entry point
                    value = URL.resolve(packages[0], value);
                }
            }

            if (value !== this._path) {
				if (1) {
					this.loadMultipleScenes();
				}
				else {
					var self = this;
					var readerDelegate = {};
					readerDelegate.loadCompleted = function (scene) {
						this.totalBufferSize =  loader.totalBufferSize;
						this.glTFElement = scene;
						this.status = "loaded";
						console.log("scene loaded:"+this._path);
					}.bind(this);

					if (value) {
						var loader = Object.create(RuntimeTFLoader);
						this.status = "loading";
						loader.initWithPath(value);
						loader.delegate = readerDelegate;
						loader.load(null /* userInfo */, null /* options */);
					} else {
						this.scene = null;
					}

					this._path = value;
				}
            }
        },

        get: function() {
            return this._path;
        }
    },

    _prepareToRenderDefer: { value: null, writable: true },

    /*
        This method doesn't need to be called directly if the rendering is done via a view.
     */
    prepareToRender: {
        value: function(webGLRenderer) {
            if (this._prepareToRenderDefer == null) {
                this._prepareToRenderDefer = Q.defer();
                var sceneResourceLoader = Object.create(SceneResourceLoader).init(this.glTFElement, webGLRenderer, this);
                sceneResourceLoader.loadScene();
            }

            return this._prepareToRenderDefer.promise;
        }
    },

    init: {
        value:function(glTFElement) {
            if (glTFElement) {
                this.glTFElement = glTFElement;
                this.status = "loaded";
            }
            return this;
        }
    },

    blueprintModuleId:require("montage")._blueprintModuleIdDescriptor,

    blueprint:require("montage")._blueprintDescriptor

});
