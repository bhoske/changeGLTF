// Copyright (c) Fabrice ROBINET
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

require("runtime/dependencies/gl-matrix");
var Utilities = require("runtime/utilities").Utilities;
var Transform = require("runtime/transform").Transform;
var Montage = require("montage").Montage;
var SceneHelper = require("runtime/scene-helper").SceneHelper;

exports.CameraController = Montage.specialize( {

    // Montage
    constructor: {
        value: function View() {
            this.super();

            this._lastPosition = [0 ,0];
			this._lastPosition1 = [0 ,0];
        }
    },

    _deltaForEvent: {
        value: function(event) {
			var result;
			if(event.keyCode == 38)
				result = 150;
			else if(event.keyCode == 40)
				result = -150;
			else
				result = event.wheelDeltaY != null ? event.wheelDeltaY*3 : -event.deltaY*3;
			return result;
        }
    },

    _minimalDistance: { value: 0, writable: true},

    _computeInitialDistance: {
        value: function() {
            if (this.sceneBBox) {
                var sceneBBox =  this.sceneBBox;

                //First we compute the sceneRadius
                var sceneBBOXMidpoint = vec3.createFrom(   (sceneBBox[1][0] - sceneBBox[0][0]) / 2, 
                                            (sceneBBox[1][1] - sceneBBox[0][1]) / 2, 
                                            (sceneBBox[1][2] - sceneBBox[0][2]) / 2)
                var sceneRadius = vec3.length(sceneBBOXMidpoint);

                //Then we check what is the starting distance from the view point to center of the sceen
                var targetPosition = [
                    (sceneBBox[0][0] + sceneBBox[1][0]) / 2,
                    (sceneBBox[0][1] + sceneBBox[1][1]) / 2,
                    (sceneBBox[0][2] + sceneBBox[1][2]) / 2];
                var eye = vec3.create(this.viewPoint.glTFElement.transform.translation);
                var direction = vec3.create();
                direction[0] = targetPosition[0] - eye[0];
                direction[1] = targetPosition[1] - eye[1];
                direction[2] = targetPosition[2] - eye[2];

                var initialDistance = vec3.length(direction);

                this._minimalDistance = (initialDistance < sceneRadius) ? initialDistance : sceneRadius;

                this.zoomStep = sceneRadius * 0.0001;
            }            
        }
    },

    viewPointDidChange: {
        value: function() {
            this._computeInitialDistance();
        }
    },

    _viewPoint: { value: null, writable: true},

    viewPoint: {
        get: function() {
            return this._viewPoint;
        },
        set: function(value) {
            if (this._viewPoint != value) {
                this._viewPoint = value;
                this.viewPointDidChange();
            }
        }
    },

    _node: { value: null, writable: true},

    zoomStep: { value: 0, writable: true },

    sceneBBox: { value: null, writable: true},

    nodeDidChange: {
        value: function() {
            var rootNode = this.node.glTFElement;
            this.sceneBBox =  rootNode.getBoundingBox(true);

            this._computeInitialDistance();
        }
    },

    node: {
        get: function() {
            return this._node;
        },
        set: function(value) {
            if (this._node != value) {
                this._node = value;
                this.nodeDidChange();
            }
        }
    },

    _lastPosition: { value: null, writable: true },
	_lastPosition1: { value: null, writable: true },

    _transform: { value: null, writable: true },

    _axisUp: { value: null, writable: true },

    zoom: {
        value: function(event) {
            if (this.moving)
                return;

            var self = this;
            var direction = vec3.create();
            var eye = vec3.create(this.viewPoint.glTFElement.transform.translation);
			//console.log("start eye x=" + eye[0] + " y=" + eye[1] + " z=" + eye[2]);
            var targetPosition;
            var rootNode = this.node.glTFElement;
            var sceneBBox =  this.sceneBBox;
            targetPosition = [
                (sceneBBox[0][0] + sceneBBox[1][0]) / 2,
                (sceneBBox[0][1] + sceneBBox[1][1]) / 2,
                (sceneBBox[0][2] + sceneBBox[1][2]) / 2];
            
            direction[0] = targetPosition[0] - eye[0];
            direction[1] = targetPosition[1] - eye[1];
            direction[2] = targetPosition[2] - eye[2];

            vec3.normalize(direction);

            var delta = this._deltaForEvent(event);

            var wheelStep =  this.zoomStep * delta;
			
			//console.log("wheelStep === " + wheelStep);
			/* // for ortho view key zoom not working trial  
			var glTFCamera = SceneHelper.getGLTFCamera(this.viewPoint);
			if(glTFCamera.projection._type == "perspective")
				wheelStep *=1;
			else
				wheelStep *=100;
			*/

            eye[0] += wheelStep * direction[0];
            eye[1] += wheelStep * direction[1];
            eye[2] += wheelStep * direction[2];
			
			
            var distVec = vec3.create();

            distVec[0] = targetPosition[0] - eye[0];
            distVec[1] = targetPosition[1] - eye[1];
            distVec[2] = targetPosition[2] - eye[2];
            var distance = vec3.length(distVec);
			this.viewPoint.glTFElement.transform.translation = eye;
			
			/* Code can be use for restricting camera zoom.. for time being it has been removed.
					
			if (distance > this._minimalDistance) {
				//console.log("if");
               this.viewPoint.glTFElement.transform.translation = eye;
            } 
			else {
                var minimalDistance = (delta > 0) ? -this._minimalDistance : this._minimalDistance;
				eye[0] = targetPosition[0] + direction[0] * minimalDistance;
                eye[1] = targetPosition[1] + direction[1] * minimalDistance;
                eye[2] = targetPosition[2] + direction[2] * minimalDistance;

                this.viewPoint.glTFElement.transform.translation = eye;
            }  */
			this.viewPoint.glTFElement.transform._dirty = true;
			//console.log("start eye x=" + this.viewPoint.glTFElement.transform.translation[0] + " y=" + this.viewPoint.glTFElement.transform.translation[1] + " z=" + this.viewPoint.glTFElement.transform.translation[2]);
			//console.log("==========================================================");
        }
    },

    translate: {
        value: function(event) {
            this._transform.matrix = this.viewPoint.glTFElement.worldMatrix;
            if (this.moving == false)
                 return;

            var xDelta, yDelta; 
			if(event._event.type == "translate")
			{
				xDelta = event.translateX - this._lastPosition[0];
				yDelta = event.translateY - this._lastPosition[1];

				this._lastPosition[0] = event.translateX;
				this._lastPosition[1] = event.translateY;
				
				xDelta  *=  0.05;
				yDelta  *=  -0.05;
			}
			else if(event._event.type == "keydown")
			{
				xDelta = 0;
				yDelta = 0;				
				if(event.keyCode == 37) //left arrow
					xDelta = -2;
				else if(event.keyCode == 39) //right arrow
					xDelta = 2;
				else if(event.keyCode == 33) //page up(33)
					yDelta = 2;
				else if(event.keyCode == 34) //page down(34)
					yDelta = -2;
					
				xDelta  *=  0.05;
				yDelta  *=  0.05;
			}

            //if (this._axisUp == null) {
                this._axisUp = vec3.createFrom(0, 1, 0);
                mat4.rotateVec3(this._transform.matrix, this._axisUp);
            //}
            var hasTarget = false;
            var targetPosition;
            if (hasTarget == false) {
                var rootNode = this.node.glTFElement;
                var sceneBBox =  this.sceneBBox;
                targetPosition = [
                    (sceneBBox[0][0] + sceneBBox[1][0]) / 2,
                    (sceneBBox[0][1] + sceneBBox[1][1]) / 2,
                    (sceneBBox[0][2] + sceneBBox[1][2]) / 2];
            }
            var direction = vec3.create();
            var eye = vec3.create(this._transform.translation);

            direction[0] = targetPosition[0] - eye[0];
            direction[1] = targetPosition[1] - eye[1];
            direction[2] = targetPosition[2] - eye[2];

            var axisUpAdjusted = vec3.create(this._axisUp);
            var right = vec3.create();
            vec3.normalize(direction);
            vec3.cross(direction, this._axisUp, right);
            vec3.normalize(right);
            vec3.cross(direction, right, axisUpAdjusted);
            vec3.normalize(axisUpAdjusted);

            var cameraMat = mat4.identity();

            var ratio = 0;
            if (Math.abs(yDelta) > Math.abs(xDelta)) {
                ratio = Math.abs(yDelta) / Math.abs(xDelta);
            } else {
                ratio = Math.abs(xDelta) / Math.abs(yDelta);
            }

            if (ratio > 0.5) {
                mat4.rotate(cameraMat, xDelta, axisUpAdjusted);
                mat4.rotate(cameraMat, yDelta, right);
            } else
            if (Math.abs(yDelta) > Math.abs(xDelta))
                mat4.rotate(cameraMat, yDelta, right);
            else
                mat4.rotate(cameraMat, xDelta, axisUpAdjusted);

            eye[0] -= targetPosition[0];
            eye[1] -= targetPosition[1];
            eye[2] -= targetPosition[2];

            mat4.rotateVec3(cameraMat, eye);

            eye[0] += targetPosition[0];
            eye[1] += targetPosition[1];
            eye[2] += targetPosition[2];

            var  rotationMatrix = mat4.identity();
            mat4.multiply3(cameraMat, this._transform.matrix,  rotationMatrix);

            var translationMatrix = mat4.identity();
            mat4.translate(translationMatrix, eye);

            var finalMat = mat4.identity();
            mat4.multiply(translationMatrix, rotationMatrix, finalMat);
            this.viewPoint.glTFElement.transform.matrix = finalMat;
        }
    },

    beginTranslate: {
        value: function(event) {
            this.moving = true;
            if (this._transform == null) {
                this._transform = Object.create(Transform).init();
            }
            this._transform.matrix = this.viewPoint.glTFElement.worldMatrix;
        }
    },

    endTranslate: {
        value: function(event) {
            this.moving = false;

            this._axisUp = null;
        }
	},
	fitallFactor : {value:2.1},
	fitall : {
		value : function(){
			//psb 
			var sceneBBox =  this.sceneBBox;
			//First we compute the sceneRadius
			var sceneBBOXMidpoint = vec3.createFrom(   (sceneBBox[1][0] - sceneBBox[0][0]) / 2, 
										(sceneBBox[1][1] - sceneBBox[0][1]) / 2, 
										(sceneBBox[1][2] - sceneBBox[0][2]) / 2)
			var sceneRadius = vec3.length(sceneBBOXMidpoint);
			var eye = vec3.create(this.viewPoint.glTFElement.transform.translation);
			//console.log("sceneRadius=" + sceneRadius);
			var glTFCamera = SceneHelper.getGLTFCamera(this.viewPoint);
			var offset = sceneRadius / Math.tan(Math.PI / 180.0 * glTFCamera.projection.yfov * 0.6); // caemera fov need to update from current at 40 value 
			var matrix = this.viewPoint.glTFElement.transform.matrix;
			var dirColumnZ = vec3.createFrom(matrix[8]*offset, matrix[9]*offset, matrix[10]*offset);
			
			var targetPosition = [
                (sceneBBox[0][0] + sceneBBox[1][0]) / 2,
                (sceneBBox[0][1] + sceneBBox[1][1]) / 2,
                (sceneBBox[0][2] + sceneBBox[1][2]) / 2];
				
			var newEyePos = vec3.create();
			vec3.add(targetPosition, dirColumnZ, newEyePos);
			this.viewPoint.glTFElement.transform.translation = newEyePos;
			this.viewPoint.glTFElement.transform.dirty = true;			
        }
	},
	panMove : {
		value : function(event)
		{
		 	this._transform.matrix = this.viewPoint.glTFElement.worldMatrix;
			var x = event._event.clientX;
			var y = event._event.clientY;
			
			var o = new Array();
			var x1 = new Array();
			var y1 = new Array();
			var v1 = vec3.createFrom(x,  y,  .5);
			var v2 = vec3.createFrom(x+1,y,  .5);
			var v3 = vec3.createFrom(x,  y-1,.5);
			
			var viewPtMatrix = this.viewPoint.glTFElement.transform.matrix;
			//var viewPtMatrix = this.viewPoint.glTFElement.worldMatrix;
			var viewMatrixInv = mat4.create();
			mat4.inverse(viewPtMatrix, viewMatrixInv);
			
			var glTFCamera = SceneHelper.getGLTFCamera(this.viewPoint);
			var projectionMatrix = glTFCamera.projection.matrix;
			
			var viewPort = vec4.createFrom(0,0, window.innerWidth, window.innerHeight);
			
			vec3.unproject(v1, viewMatrixInv, projectionMatrix, viewPort, o);
			vec3.unproject(v2, viewMatrixInv, projectionMatrix, viewPort, x1);
			vec3.unproject(v3, viewMatrixInv, projectionMatrix, viewPort, y1);
			
			var dX = vec3.create();
			var dY = vec3.create();
			vec3.subtract(x1, o, dX);
			vec3.subtract(y1, o, dY);
			
			if(glTFCamera.projection._type == "perspective")
			{
				var pan_x = (this._lastPosition1[0] - x)*100;
				var pan_y = (this._lastPosition1[1] - y)*100;
			}
			else
			{
				var pan_x = (this._lastPosition1[0] - x);
				var pan_y = (this._lastPosition1[1] - y);
			}
			
			var newEyePos = vec3.createFrom(pan_x*dX[0] + pan_y*dY[0], 
											pan_x*dX[1] + pan_y*dY[1],
											pan_x*dX[2] + pan_y*dY[2]);
			
			var eye = this.viewPoint.glTFElement.transform.translation;
			vec3.add(eye, newEyePos);
			this.viewPoint.glTFElement.transform.translation = eye;
			
			this._lastPosition1[0] = x;
			this._lastPosition1[1] = y;
			
			this.viewPoint.glTFElement.transform._dirty = true;
		}
	},
	beginPanMove: {
        value: function(event) {
            this.moving = true;
            if (this._transform == null) {
                this._transform = Object.create(Transform).init();
			}
            this._transform.matrix = this.viewPoint.glTFElement.worldMatrix;
			this._lastPosition1[0] = event.offsetX;
			this._lastPosition1[1] = event.offsetY;
		}
    },

    endPanMove: {
		value: function(event) {
			this.moving = false;
			this._lastPosition1[0] = 0;
			this._lastPosition1[1] = 0;


			this._axisUp = null;
		}
	},
	arrowKeyTranslate: {
		value : function(event){
			this.beginTranslate(event);
			this.translate(event);
		}
	}
});
